\documentclass[10pt, a4paper]{article}

\include{includes}

\title{PaP}
\author{BERASATEGUY Tanguy, GOEDEFROIT Charles}

\begin{document}

\begin{titlepage}
  \centering
  \ {} % important
  \vfill
  \vspace{1cm}
  {\scshape\LARGE\MyTitle\par}
  \vspace{0.5cm}
  {\huge\bfseries Projet : rapport3\par}
  \vspace{0.5cm}
  {\Large 4TIN804U\par}
  \vspace{1cm}
  \MyAuthor
  \vfill
  {\large2021-2022\par}
\end{titlepage}

\newpage

\tableofcontents

\newpage

\section{4.5 AVX implementation}

\subsection{4.5.1 The synchronous case}

On fait le speedup avec \emph{omp\_tile} entre les tailing \emph{opt} et \emph{avx} sur la machine
\emph{UHURA} on obtient 4483 pour opt et 4764 pour avx un speedup de $0.94 =\frac{4483}{4764}$.
Il n'y a pas une grande différence entre les 2 version car gcc a une très bonne vectorization.

\subsection{4.5.2 The asynchronous case}

On a implémenter en suivant la consigne sur sujet.
La version \emph{avx} fonction avec la variante \emph{omp\_tiled} avec un speedup de TODO:
Par-contre la version \emph{avx} ne fonctionne pas avec la variante \emph{omp\_lazy}.

Le code de la fonction :
\inputminted[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    fontsize=\footnotesize,
    linenos
]{c}{codes/ssand_do_tile_avx.c}

\section{4.7 OpenCL Implementation}

\subsection{4.7.1 Basic OpenCL Implementation}

% TODO:

sur la machine \emph{troi} on a executer la version ocl avec une taille de 1024x1024 et des tuiles
de taille 16x16, les 69191 iterations sont executer en 1648ms.

sur la machine \emph{troi} on a executer la version omp\_tiled avec une taille de 1024x1024 et
des tuiles de taille 16x16 et le tuilage opt, cela ce fini au bout de ...ms en ... iterations.

le speedup et de $4.81=\frac{332871}{69191}$.

\end{document}